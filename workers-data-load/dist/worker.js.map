{"version":3,"file":"worker.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnRA;AAUA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA9BA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAmBA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/HA;AAEA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://worker-typescript-template/./node_modules/aws4fetch/dist/aws4fetch.umd.js","webpack://worker-typescript-template/./src/handler.ts","webpack://worker-typescript-template/./src/index.ts","webpack://worker-typescript-template/webpack/bootstrap","webpack://worker-typescript-template/webpack/before-startup","webpack://worker-typescript-template/webpack/startup","webpack://worker-typescript-template/webpack/after-startup"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.aws4fetch = {}));\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * @license MIT <https://opensource.org/licenses/MIT>\n   * @copyright Michael Hart 2018\n   */\n  const encoder = new TextEncoder();\n  const HOST_SERVICES = {\n    appstream2: 'appstream',\n    cloudhsmv2: 'cloudhsm',\n    email: 'ses',\n    marketplace: 'aws-marketplace',\n    mobile: 'AWSMobileHubService',\n    pinpoint: 'mobiletargeting',\n    queue: 'sqs',\n    'git-codecommit': 'codecommit',\n    'mturk-requester-sandbox': 'mturk-requester',\n    'personalize-runtime': 'personalize',\n  };\n  const UNSIGNABLE_HEADERS = [\n    'authorization',\n    'content-type',\n    'content-length',\n    'user-agent',\n    'presigned-expires',\n    'expect',\n    'x-amzn-trace-id',\n    'range',\n    'connection',\n  ];\n  class AwsClient {\n    constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {\n      if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n      if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n      this.accessKeyId = accessKeyId;\n      this.secretAccessKey = secretAccessKey;\n      this.sessionToken = sessionToken;\n      this.service = service;\n      this.region = region;\n      this.cache = cache || new Map();\n      this.retries = retries != null ? retries : 10;\n      this.initRetryMs = initRetryMs || 50;\n    }\n    async sign(input, init) {\n      if (input instanceof Request) {\n        const { method, url, headers, body } = input;\n        init = Object.assign({ method, url, headers }, init);\n        if (init.body == null && headers.has('Content-Type')) {\n          init.body = body != null && headers.has('X-Amz-Content-Sha256') ? body : await input.clone().arrayBuffer();\n        }\n        input = url;\n      }\n      const signer = new AwsV4Signer(Object.assign({ url: input }, init, this, init && init.aws));\n      const signed = Object.assign({}, init, await signer.sign());\n      delete signed.aws;\n      return new Request(signed.url.toString(), signed)\n    }\n    async fetch(input, init) {\n      for (let i = 0; i <= this.retries; i++) {\n        const fetched = fetch(await this.sign(input, init));\n        if (i === this.retries) {\n          return fetched\n        }\n        const res = await fetched;\n        if (res.status < 500 && res.status !== 429) {\n          return res\n        }\n        await new Promise(resolve => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));\n      }\n      throw new Error('An unknown error occurred, ensure retries is not negative')\n    }\n  }\n  class AwsV4Signer {\n    constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {\n      if (url == null) throw new TypeError('url is a required option')\n      if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n      if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n      this.method = method || (body ? 'POST' : 'GET');\n      this.url = new URL(url);\n      this.headers = new Headers(headers || {});\n      this.body = body;\n      this.accessKeyId = accessKeyId;\n      this.secretAccessKey = secretAccessKey;\n      this.sessionToken = sessionToken;\n      let guessedService, guessedRegion;\n      if (!service || !region) {\n  [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);\n      }\n      this.service = service || guessedService || '';\n      this.region = region || guessedRegion || 'us-east-1';\n      this.cache = cache || new Map();\n      this.datetime = datetime || new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n      this.signQuery = signQuery;\n      this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';\n      this.headers.delete('Host');\n      const params = this.signQuery ? this.url.searchParams : this.headers;\n      if (this.service === 's3' && !this.headers.has('X-Amz-Content-Sha256')) {\n        this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');\n      }\n      params.set('X-Amz-Date', this.datetime);\n      if (this.sessionToken && !this.appendSessionToken) {\n        params.set('X-Amz-Security-Token', this.sessionToken);\n      }\n      this.signableHeaders = ['host', ...this.headers.keys()]\n        .filter(header => allHeaders || !UNSIGNABLE_HEADERS.includes(header))\n        .sort();\n      this.signedHeaders = this.signableHeaders.join(';');\n      this.canonicalHeaders = this.signableHeaders\n        .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\\s+/g, ' ')))\n        .join('\\n');\n      this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');\n      if (this.signQuery) {\n        if (this.service === 's3' && !params.has('X-Amz-Expires')) {\n          params.set('X-Amz-Expires', '86400');\n        }\n        params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n        params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);\n        params.set('X-Amz-SignedHeaders', this.signedHeaders);\n      }\n      if (this.service === 's3') {\n        try {\n          this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\\+/g, ' '));\n        } catch (e) {\n          this.encodedPath = this.url.pathname;\n        }\n      } else {\n        this.encodedPath = this.url.pathname.replace(/\\/+/g, '/');\n      }\n      if (!singleEncode) {\n        this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');\n      }\n      this.encodedPath = encodeRfc3986(this.encodedPath);\n      const seenKeys = new Set();\n      this.encodedSearch = [...this.url.searchParams]\n        .filter(([k]) => {\n          if (!k) return false\n          if (this.service === 's3') {\n            if (seenKeys.has(k)) return false\n            seenKeys.add(k);\n          }\n          return true\n        })\n        .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))\n        .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)\n        .map(pair => pair.join('='))\n        .join('&');\n    }\n    async sign() {\n      if (this.signQuery) {\n        this.url.searchParams.set('X-Amz-Signature', await this.signature());\n        if (this.sessionToken && this.appendSessionToken) {\n          this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);\n        }\n      } else {\n        this.headers.set('Authorization', await this.authHeader());\n      }\n      return {\n        method: this.method,\n        url: this.url,\n        headers: this.headers,\n        body: this.body,\n      }\n    }\n    async authHeader() {\n      return [\n        'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,\n        'SignedHeaders=' + this.signedHeaders,\n        'Signature=' + (await this.signature()),\n      ].join(', ')\n    }\n    async signature() {\n      const date = this.datetime.slice(0, 8);\n      const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();\n      let kCredentials = this.cache.get(cacheKey);\n      if (!kCredentials) {\n        const kDate = await hmac('AWS4' + this.secretAccessKey, date);\n        const kRegion = await hmac(kDate, this.region);\n        const kService = await hmac(kRegion, this.service);\n        kCredentials = await hmac(kService, 'aws4_request');\n        this.cache.set(cacheKey, kCredentials);\n      }\n      return buf2hex(await hmac(kCredentials, await this.stringToSign()))\n    }\n    async stringToSign() {\n      return [\n        'AWS4-HMAC-SHA256',\n        this.datetime,\n        this.credentialString,\n        buf2hex(await hash(await this.canonicalString())),\n      ].join('\\n')\n    }\n    async canonicalString() {\n      return [\n        this.method.toUpperCase(),\n        this.encodedPath,\n        this.encodedSearch,\n        this.canonicalHeaders + '\\n',\n        this.signedHeaders,\n        await this.hexBodyHash(),\n      ].join('\\n')\n    }\n    async hexBodyHash() {\n      let hashHeader = this.headers.get('X-Amz-Content-Sha256');\n      if (hashHeader == null) {\n        if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {\n          throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')\n        }\n        hashHeader = buf2hex(await hash(this.body || ''));\n      }\n      return hashHeader\n    }\n  }\n  async function hmac(key, string) {\n    const cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      typeof key === 'string' ? encoder.encode(key) : key,\n      { name: 'HMAC', hash: { name: 'SHA-256' } },\n      false,\n      ['sign'],\n    );\n    return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))\n  }\n  async function hash(content) {\n    return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)\n  }\n  function buf2hex(buffer) {\n    return Array.prototype.map.call(new Uint8Array(buffer), x => ('0' + x.toString(16)).slice(-2)).join('')\n  }\n  function encodeRfc3986(urlEncodedStr) {\n    return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())\n  }\n  function guessServiceRegion(url, headers) {\n    const { hostname, pathname } = url;\n    const match = hostname.replace('dualstack.', '').match(/([^.]+)\\.(?:([^.]*)\\.)?amazonaws\\.com(?:\\.cn)?$/);\n    let [service, region] = (match || ['', '']).slice(1, 3);\n    if (region === 'us-gov') {\n      region = 'us-gov-west-1';\n    } else if (region === 's3' || region === 's3-accelerate') {\n      region = 'us-east-1';\n      service = 's3';\n    } else if (service === 'iot') {\n      if (hostname.startsWith('iot.')) {\n        service = 'execute-api';\n      } else if (hostname.startsWith('data.jobs.iot.')) {\n        service = 'iot-jobs-data';\n      } else {\n        service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';\n      }\n    } else if (service === 'autoscaling') {\n      const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];\n      if (targetPrefix === 'AnyScaleFrontendService') {\n        service = 'application-autoscaling';\n      } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {\n        service = 'autoscaling-plans';\n      }\n    } else if (region == null && service.startsWith('s3-')) {\n      region = service.slice(3).replace(/^fips-|^external-1/, '');\n      service = 's3';\n    } else if (service.endsWith('-fips')) {\n      service = service.slice(0, -5);\n    } else if (region && /-\\d$/.test(service) && !/-\\d$/.test(region)) {\n  [service, region] = [region, service];\n    }\n    return [HOST_SERVICES[service] || service, region]\n  }\n\n  exports.AwsClient = AwsClient;\n  exports.AwsV4Signer = AwsV4Signer;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { AwsClient } from \"aws4fetch\";\nimport { Flight } from \"./flight\";\nimport { OpenSkyResponse } from \"./opensky\";\n\ndeclare let S3_FOLDER: string;\ndeclare let S3_BUCKET: string;\ndeclare let S3_REGION: string;\ndeclare let S3_ACCESSKEY: string;\ndeclare let S3_SECRETKEY: string;\n\nexport default async function loadData(): Promise<void> {\n    const s3Client = getS3Client();\n\n    try {\n        const data = await getFlightData();\n\n        // data.time is in seconds, but new Date expects milliseconds\n        const load_date = new Date(data.time * 1000).toISOString();\n\n        const flights = data.states\n            .map((d: unknown[]) => pivotData(d, load_date))\n            .filter((f: Flight) => f.callsign || f.position);\n\n        // 1 line per object, no array wrapper around it, no comma between objects\n        const content = flights\n            .map((f: Flight) => JSON.stringify(f))\n            .join(\"\\n\");\n\n        const filename = `${\n            S3_FOLDER ? S3_FOLDER + \"/\" : \"\"\n        }${load_date}.json`.replace(/:/g, \"-\");\n\n        const response = await uploadFileToS3(s3Client, filename, content);\n\n        if (response.ok) {\n            console.log(`uploaded ${filename}`);\n        }\n    } catch (err) {\n        console.log(\"error loading\", JSON.stringify(err), err.toString());\n    }\n}\n\nexport function getS3Client(): AwsClient {\n    return new AwsClient({\n        region: S3_REGION,\n        accessKeyId: S3_ACCESSKEY || \"\",\n        secretAccessKey: S3_SECRETKEY || \"\",\n    });\n}\n\nexport async function getFlightData(): Promise<OpenSkyResponse> {\n    // docs: https://opensky-network.org/apidoc/rest.html\n    const url = \"https://opensky-network.org/api/states/all\";\n    const res = await fetch(url, { method: \"GET\" });\n    const data = await res.json();\n    return data;\n}\n\nexport function pivotData(f: any[], load_date: string): Flight {\n    const [\n        ica024,\n        callsign,\n        origin_country,\n        time_position_num,\n        last_contact_num,\n        longitude,\n        latitude,\n        baro_altitude,\n        on_ground,\n        velocity,\n        true_track,\n        vertical_rate,\n        altitude,\n        squawk,\n        spi,\n        position_source,\n    ] = f;\n\n    const last_contact = new Date(\n        (last_contact_num as number) * 1000,\n    ).toISOString();\n    const time_position = time_position_num\n        ? new Date((time_position_num as number) * 1000).toISOString()\n        : undefined;\n    const position =\n        latitude && longitude ? `POINT (${longitude} ${latitude})` : undefined;\n\n    const flt: Flight = {\n        load_date,\n        ica024,\n        callsign: (callsign || \"\").trim(),\n        origin_country,\n        time_position,\n        last_contact,\n        longitude,\n        latitude,\n        position,\n        baro_altitude,\n        on_ground,\n        velocity,\n        true_track,\n        vertical_rate,\n        altitude,\n        squawk,\n        spi,\n        position_source,\n    };\n    return flt;\n}\n\nasync function uploadFileToS3(\n    s3Client: AwsClient,\n    filename: string,\n    data: string,\n): Promise<Response> {\n    const url = `https://${S3_BUCKET}.s3.${S3_REGION}.amazonaws.com/${filename}`;\n\n    const headers = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Content-Type\": \"application/json\",\n    };\n\n    return await s3Client.fetch(url, {\n        method: \"PUT\",\n        headers,\n        body: data,\n    });\n}\n","import loadData from \"./handler\";\n\naddEventListener(\"scheduled\", (event) => {\n    event.waitUntil(loadData());\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}